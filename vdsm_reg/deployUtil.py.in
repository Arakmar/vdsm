#
# Copyright 2009-2012 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Refer to the README and COPYING files for full details of the license
#
# Description: Deployment utilities.

import subprocess
import logging
import traceback
import socket
import re
import sys
import os
import os.path
import time
import datetime
import grp
import pwd
import shutil
from xml.sax import saxutils
import struct
import httplib
import glob
import imp
from optparse import OptionParser
import platform

try:
    from ovirtnode import ovirtfunctions
except ImportError:
    pass

# Path constants
P_BIN = '/bin/'
P_ETC_INITD = '/etc/init.d/'
P_LIB_SYSTEMD = '/lib/systemd/systemd-'
P_ROOT_SSH = pwd.getpwnam('root').pw_dir + '/.ssh'
P_ROOT_AUTH_KEYS = P_ROOT_SSH + '/authorized_keys'
P_VDSM_NODE_ID = '/etc/vdsm/vdsm.id'
P_SBIN = '/sbin/'
P_USR_BIN = '/usr/bin/'
P_USR_SBIN = '/usr/sbin/'
P_LIBEXEC = '/usr/libexec/'
_WORK_DIR = "/tmp"    # hardcoded as server use it as-is

# Executables
EX_CAT = '@CAT_PATH@'
EX_CHKCONFIG = '@CHKCONFIG_PATH@'
EX_DMIDECODE = '@DMIDECODE_PATH@'
EX_ECHO = '@ECHO_PATH@'
EX_GRUBBY = '@GRUBBY_PATH@'
EX_HWCLOCK = '@HWCLOCK_PATH@'
EX_NTPQ = '@NTPQ_PATH@'
EX_OPENSSL = '@OPENSSL_PATH@'
EX_REBOOT = '@REBOOT_PATH@'
EX_RPM = '@RPM_PATH@'
EX_SED = '@SED_PATH@'
EX_SERVICE = '@SERVICE_PATH@'
EX_SYSTEMCTL = '@SYSTEMCTL_PATH@'
EX_YUM = '@YUM_PATH@'

# Other constants
VDSM_USER = "@VDSMUSER@"
VDSM_GROUP = "@VDSMGROUP@"
QEMU_GROUP = "@QEMUGROUP@"
READ_BUF_SIZE = 1024
DEF_KEY_LEN = 2048
HTTP_TIMEOUT = 30
ERR_NO_ROUTE = 7
SCRIPT_NAME_ADD = "addNetwork"
SCRIPT_NAME_DEL = "delNetwork"
IFACE_CONFIG = "/etc/sysconfig/network-scripts/ifcfg-"
MGT_BRIDGE_NAME = "@VDSMBRIDGE@"
REMOTE_SSH_KEY_FILE = ('/engine.ssh.key.txt',)
CORE_DUMP_PATH = '/var/lib/vdsm/core'
CORE_PATTERN = '/proc/sys/kernel/core_pattern'
XML_QUOTES = {
    "\n": ' ',
    "'": '~'
}

# Regular expression used to validate content of SSH public keys:
SSH_PUBLIC_KEY_RE = re.compile(flags=re.VERBOSE, pattern=r"""
  ^
  \s*
  ssh-(rsa|dss)
  \s+
  ([A-Za-z0-9+/]+={0,2})
  (\s+[^\s]+)?
  \s*
  $
""")

#
# Script interface to use, required for
# multi-engine version support.
#
bootstrap_interface_version = 1


def isOvirt():
    """
        This function checks if current machine runs ovirt platform.
    """
    if os.path.exists('/etc/rhev-hypervisor-release'):
        return True
    elif not len(glob.glob('/etc/ovirt-node-*-release')) == 0:
        return True
    else:
        return False


def _logExec(argv, input=None):
    """
        This function executes a given shell command while logging it.
    """
    out = None
    err = None
    rc = None
    try:
        logging.debug(argv)
        stdin = None
        if input is not None:
            logging.debug(input)
            stdin = subprocess.PIPE
        p = subprocess.Popen(argv, stdin=stdin, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate(input)
        rc = p.returncode
        logging.debug(out)
        logging.debug(err)
    except:
        logging.error(traceback.format_exc())
    return (out, err, rc)


def vdsmImport(name, vdsmDir=None):
    # Legacy import for old vdsm packages
    if vdsmDir and vdsmDir not in sys.path:
        sys.path.append(vdsmDir)

    try:
        # Loading vdsm package
        fp, path, desc = imp.find_module("vdsm")
        vdsm = imp.load_module("vdsm", fp, path, desc)

        # Loading the module from the vdsm package
        fp, path, desc = imp.find_module(name, vdsm.__path__)
        imp_name = "vdsm." + name

    except ImportError:
        # Legacy import for old vdsm packages
        fp, path, desc = imp.find_module(name)
        imp_name = name

    try:
        return imp.load_module(imp_name, fp, path, desc)
    finally:
        # Since we may exit via an exception, close fp explicitly
        if fp:
            fp.close()


###############################################################################
# Host Misc functions.
###############################################################################

def escapeXML(message):
    """
        Escape '&', '<', '>', and '\n' in a given string.
    """
    return saxutils.escape(message, XML_QUOTES)


def simpleDaemon(main, args=(), kwargs={}):
    # Default maximum for the number of available file descriptors.
    MAXFD = 1024

    import resource  # Resource usage information.
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = MAXFD

    pid = os.fork()
    if pid == 0:
        try:
            os.setsid()
            for fd in range(0, maxfd):
                try:
                    os.close(fd)
                except OSError:  # ERROR, fd wasn't open to begin with(ignored)
                    pass

            os.open(os.devnull, os.O_RDWR)  # standard input (0)
            os.dup2(0, 1)  # standard output (1)
            os.dup2(0, 2)  # standard error (2)

            if os.fork() != 0:
                os._exit(0)

            main(*args, **kwargs)
        finally:
            os._exit(1)

    pid, status = os.waitpid(pid, 0)

    if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
        raise RuntimeError("Daemon not exited properly")


def delayedReboot(sleepTime):
    time.sleep(sleepTime)
    os.execl(EX_REBOOT, EX_REBOOT)


def reboot():
    logging.debug("scheduling reboot")
    try:
        simpleDaemon(delayedReboot, args=(10,))
        return True
    except:
        logging.error("Could not reboot.", exc_info=True)
        return False


def setCoreDumpPath():
    logging.debug("setCoreDumpPath started.")
    fReturn = True
    try:
        _logExec([EX_ECHO, CORE_DUMP_PATH, ">", CORE_PATTERN])
        print "<BSTRAP component='CoreDump' status='OK'/>"
    except:
        fReturn = False
        print "<BSTRAP component='CoreDump' status='FAIL'/>"

    logging.debug("setCoreDumpPath end:" + str(fReturn))
    return fReturn


def _removeNoError(file):
    try:
        os.remove(file)
    except OSError:
        pass


def cleanAll(random_num):
    """ Remove temp files.
    """

    #
    # Old vds_installer.py did not cleanup after
    # running
    #
    if bootstrap_interface_version == 1:
        for f in (
            '/vds_bootstrap_%s.py' % random_num,
            '/vds_bootstrap_complete_%s.py' % random_num,
            '/deployUtil.py'
        ):
            _removeNoError(_WORK_DIR + f)
            _removeNoError(_WORK_DIR + f + "c")

    for f in (
        '/req_%s.conf' % random_num,
        '/cert_%s.req' % random_num,
        '/cert_%s.pem' % random_num,
        '/CA_%s.pem' % random_num,
        '/ovirt-id_rsa_%s' % random_num
    ):
        _removeNoError(_WORK_DIR + f)

    print "<BSTRAP component='cleanAll' status='OK'/>"
    logging.debug("cleanAll end")

    return True


def setVdsConf(configStr, confFile):
    """
        This function changes local configuration according to the
        given 'key=value;' string.
    """
    logging.debug("setVdsConf: started. config:" + str(configStr))
    if not configStr:
        logging.debug("setVdsConf: nothing to set.")
        return

    if not os.path.exists(confFile):
        logging.debug("setVdsConf does not exist: " + confFile)
        raise RuntimeError("File " + confFile + "does not exist.")

    new_config_params = {}
    config_params = configStr.split(';')
    for item in config_params:
        key = item.split('=')[0].strip()
        val = item.split('=')[1].strip()
        new_config_params[key] = val

    for key in new_config_params.keys():
        val = new_config_params[key]
        logging.debug("setVdsConf: setting Key=" + str(key) + " to val=" +
                      str(val))
        _updateFileLine(confFile, key, val)
        #_logExec([EX_SED, "-i", "s:^\s*"+key+"\s*=.*:"+key+"="+val+":",
        #         confFile])

    if isOvirt():
        # save the updated file
        logging.debug("setVdsConf: saving new config file")
        ovirtfunctions.ovirt_store_config(confFile)

    logging.debug("setVdsConf: ended.")


def getMachineUUID():
    """
        This function parses the DMI data for the host's UUID. If not found,
        returns "None".
    """
    arch = platform.machine()
    if arch == 'x86_64':
        out, err, ret = _logExec([EX_DMIDECODE, "-s", "system-uuid"])
        out = '\n'.join(line for line in out.splitlines()
                        if not line.startswith('#'))

        # Avoid error string- 'Not Settable' or 'Not Present'
        if ret == 0 and "Not" not in out:
            return out.replace("\n", "")
    elif arch == "ppc64":
        if os.path.exists('/proc/device-tree/system-id'):
            #eg. output IBM,03061C14A
            return file('/proc/device-tree/system-id').readline().\
                replace(",", "")

    logging.error("getMachineUUID: Could not find machine's UUID.")

    return "None"


def getMacs():

    # (
    #     find /sys/class/net/*/device | while read f; do \
    #         cat "$(dirname "$f")/address"; \
    #     done; \
    #     [ -d /proc/net/bonding ] && \
    #         find /proc/net/bonding -type f -exec cat '{}' \; | \
    #         grep 'Permanent HW addr:' | \
    #         sed 's/.* //'
    # ) | sed -e '/00:00:00:00/d' -e '/^$/d'

    macs = []
    for b in glob.glob('/sys/class/net/*/device'):
        mac = file(os.path.join(os.path.dirname(b), "address")). \
            readline().replace("\n", "")
        macs.append(mac)

    for b in glob.glob('/proc/net/bonding/*'):
        for line in file(b):
            if line.startswith("Permanent HW addr: "):
                macs.append(line.split(": ")[1].replace("\n", ""))

    return set(macs) - set(["", "00:00:00:00:00:00"])


def getHostID():
    """
        This function concatenate the first serted mac address to the machine's
        UUID.
    """
    strReturn = "None"

    if os.path.exists(P_VDSM_NODE_ID):
        if isOvirt():
            ovirtfunctions.ovirt_store_config(P_VDSM_NODE_ID)
        strReturn = open(P_VDSM_NODE_ID).readline().replace("\n", "")
    else:
        strReturn = getMachineUUID()

        macs = getMacs()

        if len(macs) > 0:
            strMAC = sorted(macs)[0]
        else:
            strMAC = ""
            logging.warning("getHostID: Could not find machine's MAC, "
                            "returning UUID only.")

        if strReturn != "None":
            strReturn += "_" + strMAC
        else:
            strReturn = "_" + strMAC

    logging.debug("getHostID: " + str(strReturn))
    return strReturn


def _getIfaceByIP(addr):
    remote = struct.unpack('I', socket.inet_aton(addr))[0]
    for line in file('/proc/net/route').readlines()[1:]:
        iface, dest, gateway, flags, refcnt, use, metric, \
            mask, mtu, window, irtt = line.split()
        dest = int(dest, 16)
        mask = int(mask, 16)
        if remote & mask == dest & mask:
            return iface

    return None  # Should never get here w/ default gw


def _getMGTIface(vdcHostName):
    strVDCIP = "None"
    strReturn = None
    strVDCName = vdcHostName

    try:
        if vdcHostName != "None":
            logging.debug("_getMGTIface: read host name: " + strVDCName)
            #Now find the IP. Note that gethostbyname(IP) == IP
            strVDCIP = socket.gethostbyname(strVDCName)
    except:
            strVDCIP = "None"
            logging.debug("_getMGTIface: error trying to figure out IP")

    logging.debug("_getMGTIface: using host name " + strVDCName + " strIP= " +
                  strVDCIP)

    # Find the interface of the management IP
    if strVDCIP != "None":
        strReturn = _getIfaceByIP(strVDCIP)

    logging.debug("_getMGTIface IP=" + str(strVDCIP) + " strIface=" +
                  str(strReturn))
    return strReturn


def getMGTIP(vdsmDir, vdcHostName):
    strReturn = "None"

    try:
        netinfo = vdsmImport("netinfo", vdsmDir)
    except:
        logging.error("getMGTIP: Failed to find vdsm modules!")
        return strReturn

    strIface = _getMGTIface(vdcHostName)

    if strIface is not None:
        strReturn = netinfo.getaddr(strIface)

    logging.debug("getMGTIP: Host MGT IP=" + strReturn)
    return strReturn


def preventDuplicate(bridgeName=None):
    """
      This function checks if the needed bridge (@VDSMBRIDGE@) already exist.
    """
    if bridgeName is None:
        bridgeName = MGT_BRIDGE_NAME
    fFound = False

    if os.path.exists('/sys/class/net/' + bridgeName):
        fFound = True
        logging.debug("Bridge %s already exists." % bridgeName)
    else:
        logging.debug("Bridge %s not found, need to create it." % bridgeName)

    return fFound


def getOSVersion():
    """
    Return the OS release, similarly to `lsb_release -rs`

    Return "Unknown OS" on any failure.
    """

    # platform.linux_distribution returns a tuple (distname, version, id) or
    # default as given in args in case of any failure
    osVer = platform.linux_distribution(distname='', version='Unknown OS')
    logging.debug("OS Release Ver = %s", osVer[1])
    return osVer[1]


def getKernelVR():
    """Return current kernel version and release."""

    components = os.uname()[2].split('-', 1)
    if len(components) == 2:
        return components
    else:
        return components[0], '0'


def compareVR(vr1, vr2):
    import rpmUtils.miscutils

    return rpmUtils.miscutils.compareEVR((0, vr1[0], vr1[1]),
                                         (0, vr2[0], vr2[1]))


def updateKernelArgs(arg):
    """
        Update current kernel arguments using grubby.
    """
    fReturn = False
    try:
        out, err, ret = _logExec([EX_GRUBBY, "--update-kernel",
                                  "DEFAULT", "--args", arg])
        if not ret:
            fReturn = True
    except:
        pass

    return fReturn


def getAddress(url):
    logging.debug("getAddress Entry. url=" + str(url))
    import urlparse
    strRetAddress = None
    strRetPort = None
    scheme = None
    netloc = None
    path = None
    query = None
    fragment = None

    (scheme, netloc, path, query, fragment) = urlparse.urlsplit(url)
    if scheme != '':
        # ('http', 'www.redhat.com', '/rhel/virtualization/', '', '')
        strRetAddress = netloc
    elif path != '':  # ('', '', 'www.redhat.com', '', '')
        strRetAddress = path
    else:
        logging.error("Unable to parse: " + str(url))

    # Find port
    if strRetAddress is not None and ":" in strRetAddress:
        strRetAddress, strRetPort = strRetAddress.split(":")

    logging.debug("getAddress return. address=" + str(strRetAddress) +
                  " port=" + str(strRetPort))
    return strRetAddress, strRetPort


def waitRouteRestore(maxCount, targetIP):
    logging.debug("waitRouteRestore Entry. maxCount=" + str(maxCount) +
                  " targetIP:" + targetIP)

    fReturn = True
    count = 0
    ret1 = ERR_NO_ROUTE  # no route error code
    while(count < maxCount and ret1 == ERR_NO_ROUTE):
        try:
            out1, err1, ret1 = _logExec([
                '/usr/bin/curl',
                '-s',
                '--connect-timeout', '10',
                '--max-filesize', '10',
                targetIP
            ])
        except:
            pass

        count = count + 1
        logging.debug(
            " count=" + str(count - 1) +
            "\nout=" + out1 +
            "\nerr=" + str(err1) +
            "\nret=" + str(ret1)
        )
        time.sleep(1)

    if ret1 == ERR_NO_ROUTE:
        fReturn = False

    logging.debug("waitRouteRestore Return. fReturn=" + str(fReturn))
    return fReturn


def setService(srvName, action):
    """
        Perform an action (stop/start/status/...) on a service
    """

    srvCtlName = srvName + ".service"

    nReturn = 0
    out = None
    err = None
    if srvName is None:
        nReturn = 1
        message = "setService: ignoring None service."
        err = message
        logging.error(message)
    elif os.path.exists(P_ETC_INITD + srvName):
        out, err, nReturn = _logExec([EX_SERVICE, srvName, action])
    elif os.path.exists(P_LIB_SYSTEMD + srvName):
        out, err, nReturn = _logExec([EX_SYSTEMCTL, action, srvCtlName])
        # a hack until we have vdsm-tool to reconfigure Vdsm after installation
        EX_SYSTEMD_VDSMD = '/lib/systemd/systemd-vdsmd'
        if nReturn == 1 and srvName == 'vdsmd' \
                and err.startswith('Unknown operation'):
            out, err, nReturn = _logExec([EX_SYSTEMD_VDSMD, action])
    else:
        nReturn = 1
        err = "No such service: " + srvName

    return out, err, nReturn


def systemCtl(srvName, action, level=None):
    """
    Perform a set action (on/off/reset) on a systemd service
    """

    srvCtlName = srvName + ".service"

    if action == "off":
        out, err, nReturn = _logExec([EX_SYSTEMCTL, "is-enabled", srvCtlName])

        # Service not present or not enabled
        if nReturn != 0:
            return "", "", 0

        out, err, nReturn = _logExec([EX_SYSTEMCTL, "disable", srvCtlName])

    elif action == "on":
        out, err, nReturn = _logExec([EX_SYSTEMCTL, "enable", srvCtlName])

    elif action == "reset":
        raise Exception("The 'reset' action is not yet implemented for "
                        "systemd")

    return out, err, nReturn


def chkConfig(srvName, action, level=None):
    """
    Perform a set action (on/off/reset) on an init script
    """
    if os.path.exists(EX_SYSTEMCTL):
        return systemCtl(srvName, action, level)

    nReturn = 0
    out = None
    err = None

    if os.path.exists(P_ETC_INITD + srvName):
        if level:
            out, err, nReturn = _logExec([EX_CHKCONFIG, '--level', level,
                                         srvName, action])
        else:
            out, err, nReturn = _logExec([EX_CHKCONFIG, srvName, action])
    else:
        if action != "off":
            nReturn = 1
            err = "No such service: " + srvName
        else:
            logging.debug("chkConfig: ignoring uninstalled service: " +
                          str(srvName))

    return out, err, nReturn


###############################################################################
# Host SSH functions.
###############################################################################

def getAuthKeysFile(IP, port):
    """
        This functions returns the public ssh key of @ENGINENAME@.
    """
    _, _, engineWebCACert = certPaths('')
    data = None
    for key in REMOTE_SSH_KEY_FILE:
        tmp = getRemoteFile(IP, port, key, timeout=HTTP_TIMEOUT,
                            certPath=engineWebCACert)
        if tmp is not None and validateSSHKey(tmp):
            data = tmp
            break

    return data


def addSSHKey(path, strKey):
    resKeys = []

    try:
        for key in file(path):
            if not key.endswith('\n'):  # make sure we have complete lines
                key += '\n'
            if key != '\n' and not key.endswith(" ovirt-engine\n") or \
                    key.startswith("#"):
                resKeys.append(key)
    except IOError:
        logging.debug("Failed to read %s", path)
    if not strKey.endswith('\n'):
        strKey += '\n'
    resKeys.append(strKey)

    if isOvirt():
        # No problem to write to the original file here, since until it is not
        # persisted the old values are in place
        open(path, 'w').write(''.join(resKeys))
    else:
        tmpFilePath = path + '.tmp'
        open(tmpFilePath, 'w').write(''.join(resKeys))
        os.rename(tmpFilePath, path)


def silentRestoreCon(path):
    """silently ignore restorecon exceptios, when SELinux is disabled"""
    import selinux
    try:
        return selinux.restorecon(path)
    except:
        logging.error('restorecon %s failed', path, exc_info=True)


def validateSSHKey(strKey):
    """Check that the given string is a valid SSH public key"""
    if SSH_PUBLIC_KEY_RE.match(strKey) is None:
        logging.debug("validateSSHKey: the string \"%s\" is not a valid SSH "
                      "key" % strKey)
        return False
    else:
        return True


def handleSSHKey(strKey):
    """
        This functions appends a given key to the root's authorized_keys file.
    """
    fReturn = True
    logging.debug('handleSSHKey start')
    if not os.path.exists(P_ROOT_SSH):
        logging.debug("handleSSHKey: creating .ssh dir.")
        try:
            os.mkdir(P_ROOT_SSH, 0700)
            silentRestoreCon(P_ROOT_SSH)
        except OSError:
            fReturn = False
            logging.debug("handleSSHKey: failed to create ssh dir!")

    if fReturn:
        try:
            addSSHKey(P_ROOT_AUTH_KEYS, strKey)
        except:
            fReturn = False
            logging.debug("handleSSHKey: failed to write authorized_keys!",
                          exc_info=True)

    if fReturn:
        try:
            os.chmod(P_ROOT_AUTH_KEYS, 0644)
            silentRestoreCon(P_ROOT_AUTH_KEYS)
        except:
            fReturn = False
            logging.debug("handleSSHKey: failed to chmod authorized_keys",
                          exc_info=True)

    if fReturn and isOvirt():
        # persist authorized_keys
        logging.debug("handleSSHKey: persist authorized_keys")
        ovirtfunctions.ovirt_store_config(P_ROOT_AUTH_KEYS)

    logging.debug('handleSSHKey end')
    return fReturn


###############################################################################
# Host time functions.
###############################################################################

def setHostTime(VDCTime):
    logging.debug('setHostTime start.')
    import time
    fReturn = True

    out, err, rc = _logExec([EX_NTPQ, "-c", "rv"])
    if out and 'clock_sync' in out:
        logging.debug("setHostTime: Time is synchronised to NTP server.")
    else:
        try:
            ttp = time.strptime(VDCTime, '%Y-%m-%dT%H:%M:%S')
        except ValueError as e:
            logging.debug("setHostTime: Failed to parse @ENGINENAME@ time. "
                          "message= " + str(e))
            fReturn = False

        if fReturn:
            out, err, rc = _logExec(
                [EX_HWCLOCK, "--set", "--utc",
                 time.strftime('--date=%Y-%m-%d %H:%M:%S UTC', ttp)])
            if rc:
                logging.debug("setHostTime: Failed to set hwclock time. out=" +
                              out + "\nerr=" + str(err) + "\nrc=" + str(rc))
                fReturn = False

        if fReturn:
            out, err, rc = _logExec([EX_HWCLOCK, "-s"])
            if rc:
                logging.debug("setHostTime: Failed to sync hwclock time to "
                              "host. out=" + out + "\nerr=" + str(err) +
                              "\nrc=" + str(rc))
                fReturn = False

    logging.debug('setHostTime end. Return:' + str(fReturn))
    return fReturn


###############################################################################
# Update configuration file functions.
###############################################################################

def _updateFileLine(fileName, key, value, insertIfMissing=False):
    """
        Update a line of a configuration file. This function will replace the
        whole line!
        The function returns success is replacment took place.
    """
    import stat
    from tempfile import mkstemp
    fReplaced = False
    logging.debug(
        "_updateFileLine: entry. File: " + str(fileName) +
        " key=" + str(key) +
        " value=" + str(value)
    )

    try:
        #Preserve current file mode
        mode = os.stat(fileName)[stat.ST_MODE]

        #Create temp file
        fh, abs_path = mkstemp()
        new_file = open(abs_path, 'w')
        old_file = open(fileName)
        #Iterate over the existing file, while replacing if needed.
        for line in old_file:
            # Note: the line below must not have spaces before or after the '='
            #       since it'll fail bash scripts !
            newLine = re.sub('^[#\s]*%s\s*=.*' % key, '%s=%s' % (key, value),
                             line)
            if re.match('^%s=%s$' % (re.escape(key), re.escape(value)),
                        newLine):
                logging.debug("_updateFileLine: replacing " + str(line) +
                              " with: " + newLine)
                fReplaced = True
                line = newLine
            new_file.write(line)
        if insertIfMissing and not fReplaced:
            new_file.write("%s=%s\n" % (key, value))
            fReplaced = True
        new_file.close()
        os.close(fh)
        old_file.close()
        #Move new file
        shutil.move(abs_path, fileName)

        #Restore original file mode
        os.chmod(fileName, mode)
    except:
        try:
            old_file.close()
        except:
            pass
        logging.error("_updateFileLine: error replacing " + str(key) + "=" +
                      str(value))
        logging.error(traceback.format_exc())

    logging.debug("_updateFileLine: return: " + str(fReplaced))
    return fReplaced


###############################################################################
# Host bridge functions.
###############################################################################

def _getBridgeParams(bridgeName):
    import shlex

    fIsBridgeDevice = False
    lstReturn = []
    fileName = IFACE_CONFIG + bridgeName

    try:
        for line in file(fileName):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            elif line.startswith("DEVICE=") or line.startswith("HWADDR="):
                continue
            elif line.startswith("NM_CONTROLLED="):
                continue
            elif line.startswith("TYPE="):
                t = line.split("=", 1)[1].strip()
                fIsBridgeDevice = (t == "Bridge")
            else:
                try:
                    line = ''.join(shlex.split(line))
                except:
                    logging.warn("_getBridgeParams: failed to read parse line "
                                 "%s", line)
                lstReturn.append(line)
    except Exception as e:
        logging.error("_getBridgeParams: failed to read params of file " +
                      fileName + ".\n Error:" + str(e))
        lstReturn = []

    return lstReturn, fIsBridgeDevice


def _getOvirtBridgeParams(mgtBridge):
    """
        This helper function extract the relevant parameters of the existing
        ovirt bridge in order to re-create it as a managment bridge.
    """
    netinfo = vdsmImport("netinfo")

    vlan = ''
    bonding = ''
    nic = None
    nics = []

    try:
        vlan, bonding, nics = netinfo.getVlanBondingNic(mgtBridge)
        nic = nics[0]
    except:
        nic = None
        logging.error("_getOvirtBridgeParams Failed to get bridge data:")
        logging.error(traceback.format_exc())

    return vlan, bonding, nic


def _getRHELBridgeParams(mgtIface, bridgeName=None):
    """
        This helper function extract the relevant parameters of the existing
        RHEL interface, in order to create a managment bridge.
    """
    netinfo = vdsmImport("netinfo")

    vlan = ''
    bonding = ''
    nic = None

    try:
        vlans = netinfo.vlans()
        if mgtIface in vlans:
            nic = netinfo.getVlanDevice(mgtIface)
            vlan = netinfo.getVlanID(mgtIface)
        else:
            nic = mgtIface

        if nic in netinfo.bondings():
            logging.error(
                (
                    "_getRHELBridgeParams Found bonding: %s."
                    "This network configuration is not"
                    "supported! Please configure %s bridge"
                    "manually and re-install."
                ) % (nic, bridgeName)
            )
            nic = None
    except:
        logging.error("_getRHELBridgeParams Failed to test for VLAN data")
        logging.error(traceback.format_exc())
        nic = None

    return vlan, bonding, nic


def setSafeVdsmNetworkConfig():
    """consider current network configuration as safe and remove its backup"""
    if versionCompare(getOSVersion(), "6.0") < 0:
        shutil.rmtree("/etc/sysconfig/network-scripts/.vdsmback")
    else:
        import glob
        for f in glob.glob("/var/lib/vdsm/netconfback/*"):
            if os.path.isdir(f):
                shutil.rmtree(f)
            else:
                os.remove(f)


def makeBridge(vdcName, vdsmDir, bridgeName=None):
    """
        Create (for RHEL) or rename (oVirt default bridge) to @VDSMBRIDGE@
        bridge.
    """
    logging.debug('makeBridge begin.')
    if bridgeName is None:
        bridgeName = MGT_BRIDGE_NAME

    try:
        vdsmImport("netinfo", vdsmDir)
    except ImportError:
        logging.error("makeBridge Failed to find vdsm modules!")
        return False

    fReturn = True
    out = ""
    err = None
    ret = None
    nic = None
    fIsOvirt = isOvirt()

    # get current management interface
    mgtIface = _getMGTIface(vdcName)
    if mgtIface is None:
        fReturn = False
        logging.debug("makeBridge got mgtIface None. This is a routing or "
                      "resolution issue.")
    else:
        mgtBridge = mgtIface
        if fIsOvirt and mgtIface.startswith('br'):
            # oVirt naming convention: br + iface
            mgtIface = mgtIface.replace("br", "", 1)

    if fReturn:
        # Read params from current bridge (bootproto, etc)
        Iface = mgtIface
        if fIsOvirt:
            Iface = mgtBridge
        lstBridgeOptions, fIsBridgeDevice = _getBridgeParams(Iface)

        if len(lstBridgeOptions) == 0:
            logging.error("makeBridge Failed to read existing nic parameters")
            fReturn = False
        elif fIsBridgeDevice and not fIsOvirt:
            logging.error("makeBridge found existing bridge named: " + Iface)
            fReturn = False
        else:
            logging.debug("makeBridge found the following bridge paramaters: "
                          + str(lstBridgeOptions))
            # No more handling GATEWAYDEV.

    if fReturn:
        if fIsOvirt and fIsBridgeDevice:
            vlan, bonding, nic = _getOvirtBridgeParams(mgtBridge)
        else:
            vlan, bonding, nic = _getRHELBridgeParams(mgtIface,
                                                      bridgeName=bridgeName)
        fReturn = (nic is not None)

    #Delete existing bridge in oVirt
    if fReturn and fIsOvirt and fIsBridgeDevice:
        try:
            out, err, ret = _logExec([os.path.join(vdsmDir, SCRIPT_NAME_DEL),
                                      mgtBridge, vlan, bonding, nic])
            if ret:
                if ret == 17:  # ERR_BAD_BRIDGE
                    logging.debug("makeBridge Ignoring error of del existing "
                                  "bridge. out=" + out + "\nerr=" + str(err) +
                                  "\nret=" + str(ret))
                else:
                    fReturn = False
                    logging.debug("makeBridge Failed to del existing bridge. "
                                  "out=" + out + "\nerr=" + str(err) +
                                  "\nret=" + str(ret))
            else:
                ovirtfunctions.ovirt_safe_delete_config(IFACE_CONFIG +
                                                        mgtBridge)
        except:
            fReturn = False
            logging.debug("makeBridge Failed to del existing bridge. out=" +
                          out + "\nerr=" + str(err) + "\nret=" + str(ret))

    #Add bridge
    if fReturn:
        try:
            lstBridgeOptions.append('blockingdhcp=true')
            out, err, ret = _logExec([os.path.join(vdsmDir, SCRIPT_NAME_ADD),
                                      bridgeName, vlan, bonding, nic]
                                     + lstBridgeOptions)
            if ret:
                raise Exception('Failed to add bridge')
        except:
            fReturn = False
            logging.debug(
                (
                    "makeBridge Failed to add %s bridge out=%s\n"
                    "err=%s\n"
                    "ret=%s"
                ) % (bridgeName, out, err, ret)
            )

    #Save current config by removing the undo files:
    try:
        if fReturn and not fIsOvirt:
            setSafeVdsmNetworkConfig()
    except:
        logging.debug(traceback.format_exc())

    if not fReturn:
        logging.error(
            "makeBridge errored: " +
            " out=" + out +
            "\nerr=" + str(err) +
            "\nret=" + str(ret)
        )

    logging.debug('makeBridge return.')
    return fReturn


###############################################################################
# Host package / rpm functions.
###############################################################################

def getPackageInfo(pckg_type, rpm_name, op):
    """
        Return an indication if given package name is installed or not.
    """
    strReturn = "FAIL"
    out, err, rc = _logExec([EX_RPM, "-q", rpm_name])
    if rc:
        if op == 'install':
            if pckg_type != "DEVEL":
                strReturn = "FAIL"
                out += err
            else:
                strReturn = "WARN"
        else:
            strReturn = "WARN"
    else:
        strReturn = "OK"

    return strReturn, out


def versionCompare(pkg1, pkg2):
    """
        Return an indication if given package1 is:
        -1: pkg1 < pkg2
        0: pkg1 == pkg2
        1: pkg1 > pkg2
        99 import Exception
    """
    nReturn = 0

    try:
        import rpmUtils
        import rpmUtils.miscutils
    except:
        nReturn = 99

    if nReturn == 0:
        nReturn = rpmUtils.miscutils.compareEVR(
            rpmUtils.miscutils.stringToVersion(pkg1),
            rpmUtils.miscutils.stringToVersion(pkg2)
        )

    return nReturn


def yumCleanCache():
    """
        Make sure that yum cache is valid. This function makes yum revalidate
        the cache for each repo next time it is used.
    """
    fReturn = False
    out, err, ret = _logExec([EX_YUM, "clean", "expire-cache"])
    if not ret:
        fReturn = True

    return fReturn


def yumInstallDeleteUpdate(pckgName, action, args=None):
    """
        Call yum to install, delete or update a given package name.
    """
    execFunc = [EX_YUM, "-y"]
    if args is not None:
        execFunc += args

    if action == "install":
        execFunc.append(action)
    elif action == "remove":
        execFunc.append(action)
    else:
        execFunc.append("update")
    execFunc.append(pckgName)

    return _logExec(execFunc)


def installAndVerify(pckgType, pckgName, action, args=None):
    """
        This function uses other module functions to install or update
        a package, and then verify it.
    """
    fReturn = True
    out, err, ret = yumInstallDeleteUpdate(pckgName, action, args=None)
    msg = None
    if not ret:
        fReturn, msg = getPackageInfo(pckgType, pckgName, 'install')
    else:
        fReturn = False
        msg = out + err

    return fReturn, msg


def yumListPackages(pkgName):
    """
        Returns a list of available packages exists in yum's db.
    """
    import yum

    my = yum.YumBase()
    my.preconf.debuglevel = 0  # Remove yum noise
    return my.pkgSack.searchNevra(name=pkgName)


def yumSearchVersion(pkgName, ver):
    "Return True if package exists in yum's db with the given version or higer"
    import rpmUtils.miscutils

    for pkg in yumListPackages(pkgName):
        if rpmUtils.miscutils.compareEVR(('', pkg.ver, ''),
                                         ('', ver, '')) >= 0:
            return True
    else:
        return False


###############################################################################
# Host PKI functions.
###############################################################################

def _tsDir(confFile):
    import ConfigParser

    config = ConfigParser.ConfigParser()
    config.read(confFile)
    try:
        tsDir = config.get('vars', 'trust_store_path')
    except:
        tsDir = '/etc/pki/vdsm'
    return tsDir


def certPaths(confFile, fAddID=False):
    tsDir = _tsDir(confFile)

    VDSMCERT = tsDir + "/certs/vdsmcert.pem"
    if fAddID:
        VDSMCERT = tsDir + "/certs/vdsm-" + \
            os.environ.get("SSH_CONNECTION").split()[2] + "-cert.pem"
    CACERT = tsDir + "/certs/cacert.pem"
    engineWebCACert = tsDir + "/certs/engine_web_ca.pem"

    return CACERT, VDSMCERT, engineWebCACert


def pkiCleanup(key, cert):
    """
        Removes all the previously installed keys and certificates
    """
    if os.path.exists(key):
        if isOvirt():
            ovirtfunctions.ovirt_safe_delete_config(key)
        else:
            os.unlink(key)

    if os.path.exists(cert):
        if isOvirt():
            ovirtfunctions.ovirt_safe_delete_config(cert)
        else:
            os.unlink(cert)


def _linkOrPersist(src, dst):
    # we have to copy the key and cert since ovirt currently cannot persist
    # softlinks
    if isOvirt():
        shutil.copy2(src, dst)
        st = os.stat(src)
        os.chown(dst, st.st_uid, st.st_gid)
        ovirtfunctions.ovirt_store_config(dst)
    else:
        try:
            os.unlink(dst)
        except:
            pass
        os.symlink(src, dst)


def instCert(random_num, confFile):
    """ Install certificate.
    """
    fReturn = True

    try:
        logging.debug("instCert: start. num=" + str(random_num))
        # build semi-random filenames
        cert_pemfile = _WORK_DIR + '/cert_' + random_num + '.pem'
        ca_pemfile = _WORK_DIR + '/CA_' + random_num + '.pem'
        gGroup = grp.getgrnam(VDSM_GROUP)
        nGID = gGroup.gr_gid
        uUserInfo = pwd.getpwnam(VDSM_USER)
        nUID = uUserInfo.pw_uid
        CACERT, VDSMCERT, engineWebCACert = certPaths(confFile)

        # Delete old certificates
        logging.debug("instCert: try to delete old certificates")
        pkiCleanup(VDSMCERT, CACERT)

        logging.debug("instCert: install new certificates")
        # install .pem files
        shutil.copy(cert_pemfile, VDSMCERT)
        os.chown(VDSMCERT, nUID, nGID)
        os.chmod(VDSMCERT, 0444)
        if not os.path.exists(CACERT):
            shutil.copy(ca_pemfile, CACERT)
        os.chown(CACERT, nUID, nGID)
        os.chmod(CACERT, 0444)

        if isOvirt():
            # save the certificates
            logging.debug("instCert: persist new certificates")
            ovirtfunctions.ovirt_store_config(VDSMCERT)
            ovirtfunctions.ovirt_store_config(CACERT)

        ts = _tsDir(confFile)
        VDSMKEY = ts + '/keys/vdsmkey.pem'
        SPICEPKIPATH = os.path.join(ts, 'libvirt-spice')

        if not os.path.exists(SPICEPKIPATH):
            os.makedirs(SPICEPKIPATH)

        os.chown(SPICEPKIPATH, 0, nGID)
        os.chmod(SPICEPKIPATH, 0750)

        _linkOrPersist(CACERT, ts + '/libvirt-spice/ca-cert.pem')
        _linkOrPersist(VDSMCERT, ts + '/libvirt-spice/server-cert.pem')
        _linkOrPersist(VDSMKEY, ts + '/libvirt-spice/server-key.pem')
        if not os.path.exists('/etc/pki/libvirt/private'):
            os.makedirs('/etc/pki/libvirt/private')
        _linkOrPersist(VDSMCERT, '/etc/pki/libvirt/clientcert.pem')
        _linkOrPersist(VDSMKEY, '/etc/pki/libvirt/private/clientkey.pem')
        _linkOrPersist(CACERT, '/etc/pki/CA/cacert.pem')

        print "<BSTRAP component='instCert' status='OK'/>"
        logging.debug("instCert: ended.")
    except:
        fReturn = False
        logging.debug("instCert: failed.", exc_info=True)
        print "<BSTRAP component='instCert' status='FAIL'/>"

    return fReturn


def getSSLSocket(sock, certPath=None):
    """
        Returns ssl socket according to python version
    """
    try:
        import ssl
        if not certPath:
            return ssl.wrap_socket(sock)
        else:
            return ssl.wrap_socket(sock, ca_certs=certPath,
                                   cert_reqs=ssl.CERT_REQUIRED)
    except ImportError:
        # in python 2.4 importing ssl will fail
        ssl = socket.ssl(sock)
        return httplib.FakeSocket(sock, ssl)


def createCSR(orgName, subject, random_num, tsDir, vdsmKey):
    template = """
    RANDFILE               = ~/.rnd
    [ req ]
    distinguished_name     = req_distinguished_name
    prompt                 = no
    [ v3_ca ]
    subjectKeyIdentifier=hash
    authorityKeyIdentifier=keyid:always,issuer:always
    basicConstraints = CA:true
    [ req_distinguished_name ]
    O = %s
    CN = %s
    """ % (repr(orgName), subject)

    req_conffile = _WORK_DIR + '/req_' + random_num + '.conf'
    cert_reqfile = _WORK_DIR + '/cert_' + random_num + '.req'
    open(req_conffile, "w").write(template)

    if not os.path.exists(tsDir + "/keys"):
        os.mkdir(tsDir + "/keys")

    if not os.path.exists(tsDir + "/certs"):
        os.mkdir(tsDir + "/certs")

    # create private key
    _logExec([EX_OPENSSL, "genrsa", "-out", vdsmKey, str(DEF_KEY_LEN)])
    # create request for certificate
    execfn = [EX_OPENSSL, "req", "-new", "-key", vdsmKey, "-config",
              req_conffile, "-out", cert_reqfile]
    _logExec(execfn)
    if versionCompare(getOSVersion(), "6.0") < 0:
        gGroup = grp.getgrnam(VDSM_GROUP)
    else:
        gGroup = grp.getgrnam(QEMU_GROUP)
    nGID = gGroup.gr_gid
    uUserInfo = pwd.getpwnam(VDSM_USER)
    nUID = uUserInfo.pw_uid
    os.chown(vdsmKey, nUID, nGID)
    os.chmod(vdsmKey, 0440)

    if isOvirt():
        # save the certificates
        ovirtfunctions.ovirt_store_config(vdsmKey)


def _cpuid(func):
    f = file('/dev/cpu/0/cpuid')
    f.seek(func)
    return struct.unpack('IIII', f.read(16))


def _prdmsr(cpu, index):
    f = file("/dev/cpu/%d/msr" % cpu)
    f.seek(index)
    try:
        return struct.unpack('L', f.read(8))[0]
    except:
        return -1


def _cpu_has_vmx_support():
    eax, ebx, ecx, edx = _cpuid(1)
    # CPUID.1:ECX.VMX[bit 5] -> VT
    return ecx & (1 << 5) != 0


def _vmx_enabled_by_bios():
    MSR_IA32_FEATURE_CONTROL = 0x3a
    MSR_IA32_FEATURE_CONTROL_LOCKED = 0x1
    MSR_IA32_FEATURE_CONTROL_VMXON_ENABLED = 0x4

    msr = _prdmsr(0, MSR_IA32_FEATURE_CONTROL)
    return (msr & (MSR_IA32_FEATURE_CONTROL_LOCKED |
                   MSR_IA32_FEATURE_CONTROL_VMXON_ENABLED)) != \
        MSR_IA32_FEATURE_CONTROL_LOCKED


def _cpu_has_svm_support():
    SVM_CPUID_FEATURE_SHIFT = 2
    SVM_CPUID_FUNC = 0x8000000a

    eax, ebx, ecx, edx = _cpuid(0x80000000)
    if eax < SVM_CPUID_FUNC:
        return 0

    eax, ebx, ecx, edx = _cpuid(0x80000001)
    if not (ecx & (1 << SVM_CPUID_FEATURE_SHIFT)):
        return 0
    return 1


def _svm_enabled_by_bios():
    SVM_VM_CR_SVM_DISABLE = 4
    MSR_VM_CR = 0xc0010114

    vm_cr = _prdmsr(0, MSR_VM_CR)
    if vm_cr & (1 << SVM_VM_CR_SVM_DISABLE):
        return 0
    return 1


def _check_kvm_support_on_power():
    for line in file('/proc/cpuinfo').readlines():
        if ':' in line:
            k, v = line.split(':', 1)
            k = k.strip()
            v = v.strip()
        if k == 'platform':
            if 'powernv' in v.lower():
                return 1

    return 0


def cpuVendorID():
    for line in file('/proc/cpuinfo').readlines():
        if ':' in line:
            k, v = line.split(':', 1)
            k = k.strip()
            v = v.strip()
        if k == 'vendor_id' or k == 'cpu':
            if v == 'GenuineIntel':
                return v
            elif v == 'AuthenticAMD':
                return v
            elif 'power' in v.lower():
                return 'IBM_POWER'
    return ''


def virtEnabledInCpuAndBios():
    try:
        vendor = cpuVendorID()
        logging.debug('CPU vendor is %s', vendor)

        if vendor == 'GenuineIntel':
            bios_en = _vmx_enabled_by_bios()
            has_cpu = _cpu_has_vmx_support()
        elif vendor == 'AuthenticAMD':
            bios_en = _svm_enabled_by_bios()
            has_cpu = _cpu_has_svm_support()
        elif vendor == 'IBM_POWER':
            if _check_kvm_support_on_power():
                bios_en = 1
                has_cpu = 1
        else:
            return False

        logging.debug('virt support in cpu: %s, in bios: %s', has_cpu, bios_en)
        return bios_en and has_cpu
    except:
        logging.error(traceback.format_exc())
        return False


def getRemoteFile(IP, port, fileName, timeout=None, certPath=None):
    logging.debug("getRemoteFile start. IP = %s port = %s fileName = \"%s\"" %
                  (IP, port, fileName))
    data = None
    response = None
    conn = None
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    fOK = True

    try:
        nPort = 443
        if port is not None:
            nPort = int(port)

        sock.connect((IP, nPort))
        conn = httplib.HTTPSConnection(IP, nPort)
        conn.sock = getSSLSocket(sock, certPath)
        conn.request("GET", fileName)
        response = conn.getresponse()
    except:
        logging.debug("%s failed in HTTPS. Retrying using HTTP.", fileName,
                      exc_info=True)
        strPort = ":"
        if port is None:
            strPort += "80"
        else:
            strPort += port

        try:
            conn = httplib.HTTPConnection(IP + strPort)
            conn.request("GET", fileName)
            response = conn.getresponse()
        except:
            logging.error("Failed to fetch %s using http.", fileName,
                          exc_info=True)
            fOK = False
    else:
        logging.debug("%s status: %s reason: %s",
                      fileName, str(response.status), response.reason)

    if response is None or response.status != 200:
        status = ""
        if response is not None:
            status = str(response.status)
        if conn is not None:
            conn.close()
        fOK = False
        logging.error("Failed to fetch %s status %s", fileName, status)

    if fOK:
        try:
            try:
                data = str(response.read())
            except:
                logging.error("Failed to read %s", fileName, exc_info=True)
        finally:
            if conn is not None:
                conn.close()

    logging.debug('getRemoteFile end.')
    return data


def _nodeBackupCerts(certs):
    dt = datetime.datetime.now()
    backupTime = dt.strftime("%Y-%m-%d_%H%M%S")

    for pemFile in certs:
        if os.path.exists(pemFile):
            certName = os.path.basename(pemFile)
            dirName = os.path.dirname(pemFile)

            bkpCertName = dirName + "/bkp-" + backupTime + '_' + certName

            shutil.copy2(pemFile, bkpCertName)
            st = os.stat(pemFile)
            os.chown(bkpCertName, st.st_uid, st.st_gid)
            ovirtfunctions.ovirt_store_config(bkpCertName)


def nodeCleanup():
    if isOvirt():
        CACERT, VDSMCERT, engineWebCACert = certPaths('')

        _nodeBackupCerts([CACERT, VDSMCERT, engineWebCACert])
        if os.path.exists(engineWebCACert):
            ovirtfunctions.ovirt_safe_delete_config(engineWebCACert)


def getChainFromSSL(host):
    """Return certificate from SSL handlshake

    Parameters:
    host -- (host, port)

    """
    # import M2Crypto here so
    # it be done only at vdsm-reg
    # which depends on M2Crypto
    from M2Crypto import SSL

    # openssl verify callback does not
    # accept context, so we collect the chain
    # in semi-global dictionary
    #
    # a certificate may be revisit more than one time.
    #
    # format:
    #   depth: certificate
    chain = {}

    def verify(ok, store):
        chain[store.get_error_depth()] = store.get_current_cert().as_pem()
        return True

    def check_ignore(*args, **kw):
        return True

    ctx = SSL.Context()
    ctx.set_verify(
        SSL.verify_peer | SSL.verify_fail_if_no_peer_cert,
        depth=10,
        callback=verify
    )
    sock = SSL.Connection(ctx)
    # we would like to ignore any issue with certificates
    sock.set_post_connection_check_callback(check_ignore)
    sock.connect(host)
    sock.close()

    # return sorted by depth
    # first is end certificate
    return [chain[depth] for depth in sorted(chain.keys())]


def getRhevmCert(IP, port):
    """Aquire CA certificate from SSL handshake

    This certificate is saved to a file and later used
    to validate HTTPS connections with the engine web
    server.

    """
    try:
        chain = getChainFromSSL((IP, int(port)))
        ca = chain[-1]
        _, _, engineWebCACert = certPaths('')
        dirName = os.path.dirname(engineWebCACert)
        if not os.path.exists(dirName):
            os.makedirs(dirName)
        with open(engineWebCACert, "w+") as f:
            f.write(ca)

        return True
    except:
        logging.debug(
            "Failed acquiring web certificates",
            exc_info=True
        )
        return False


def generateFingerPrint(path):
    fp = ''
    cmd = [EX_OPENSSL, 'x509', '-fingerprint', '-in', path]
    out, err, rc = _logExec(cmd)
    if rc is 0:
        try:
            fp = filter(lambda l: 'Fingerprint' in
                        l, out.split())[0].split('=')[1]
        except Exception:
            logging.debug("Failed generating finger print for %s", path,
                          exc_info=True)
    else:
        logging.debug("Command %s failed with return value %d",
                      ' '.join(cmd), rc)

    return fp


def parseOptions():
    parser = OptionParser()

    parser.add_option("-s", "--server-address", action="store",
                      dest="serverIp", type="string", default=None,
                      help="IP address of @ENGINENAME@")
    parser.add_option("-p", "--server-port", action="store", dest="serverPort",
                      default=None, type="string", help="Port of @ENGINENAME@")

    parser.add_option("-d", "--download-rhevm-cert", action="store_true",
                      default=False, dest="downloadRhevmCert",
                      help="Download certificate from @ENGINENAME@")
    parser.add_option("-f", "--fingerprint", action="store",
                      dest="fingerPrint", default=None, type="string",
                      help="The fingerprint to compare to the fingerprint of "
                      "the downloaded certificate")

    parser.add_option("-c", "--node-cleanup", action="store_true",
                      default=False, dest="nodeCleanup",
                      help="Clean node from possible past residuals")

    options, args = parser.parse_args()

    return (options, args)


def main():
    options, args = parseOptions()

    if options.nodeCleanup:
        nodeCleanup()
        print 'Node clean-up successful'
        return 0
    if options.downloadRhevmCert:
        if not options.serverIp or not options.serverPort:
            print "Must supply @ENGINENAME@'s IP and port"
            return -1
        if not getRhevmCert(options.serverIp, options.serverPort):
            print 'Failed downloading the @ENGINENAME@ certificate file'
            return -1
        _, _, engineWebCACert = certPaths('')
        if options.fingerPrint:
            fp = generateFingerPrint(engineWebCACert)
            if options.fingerPrint != fp:
                print 'Expected fingerprint %s is different from recieved ' \
                    'fingerprint %s' % (options.fingerPrint, fp)
                return -1

        if isOvirt():
            ovirtfunctions.ovirt_store_config(engineWebCACert)
        print '@ENGINENAME@ certificate downloaded and verified successfully.'
        return 0
    print 'Missing arguments'
    return -1


def getBootstrapInterfaceVersion():
    return bootstrap_interface_version


def setBootstrapInterfaceVersion(v):
    global bootstrap_interface_version
    bootstrap_interface_version = v

if __name__ == '__main__':
    sys.exit(main())
